//
// Build the presentation
//
// dzslides with embedded assets:
//
//   $ asciidoc -a data-uri slides.adoc
//
// HTML5 (print):
//
//   $ asciidoc -b html5 -o outline.html slides.adoc
//
// PDF:
//
//   $ dzslides2pdf.rb slides.adoc
//
//   PDF conversion requires: ruby, qt4-make, ruby-qt4, ruby-qt4-webkit,
//   capybara, capybara-webkit,
//

= Visión estratégica **gvNIX**
v1.4, 30 oct 2014
:title: Visión estratégica gvNIX
:description: These slides are a strategic overview to gvNIX.
:copyright: CC BY-NC-SA 3.0
:corpsite: www.disid.com
:gvnixsite: www.gvnix.org
:imagesdir: images
:linkcss!:
:source-highlighter: highlightjs
:backend: dzslides
:dzslides-style: stormy
:dzslides-aspect: 4-3
:dzslides-transition: fade
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: monokai
:syntax: no-highlight

////

////

[template="notesblock"]
====
*CHARLA (INTRODUCCIÓN):*

Presentación: Enrique Ruiz, Director de I+D en DISID y Director del proyecto gvNIX

En esta charla/presentación explicaremos qué es gvNIX, en qué se diferencia de
un framework de desarrollo y por qué utilizar una herramienta de desarrollo.

Haremos un repaso de la base tecnológica de gvNIX y las funcionalidades que
ofrece a los desarrolladores.

Veremos un vídeo demo de una aplicación desarrollada con gvNIX.

====

[{topic}]
== ¿*Por qué* usamos *librerías*?

[role="incremental scatter"]
* Lenguaje + *Librerías API*
* Problema [detail]#programar *sólo* con lenguaje#
* Más *productividad* = *librerías* de terceros

[template="notesblock"]
====
*CHARLA (WHY):*

*Lenguaje + Librerías API*

Habitualmente cualquier plataforma de
desarrollo: Java, C#, Python, Groovy, etc. además del lenguaje, ofrece un
conjunto de librerías que no son más que conjuntos de funciones ya
implementadas básicas con funcionalidad imprescindible, en el caso
de la plataforma Java estas librerías se conocen como el *API Java*.

*Problema programar sólo con lenguaje*

Si tratamos de programar una aplicación con cualquier lenguaje, desde cero
usando solo el lenguaje y las librerías básicas tendríamos un problema, ya que
sólo ofrecen utilidades de bajo nivel (programación concurrente, sockets,
estructuras de datos, etc) y por tanto aspectos de programación
tan necesarios como manejo de sesiones web, componentes de interfaz de
usuario, envío de correo, etc. tendríamos que desarrollarlas a mano.

*Más productividad = librerías de terceros*

En lugar de ello es más productivo y eficiente usar librerías de terceros que
ofrezcan estas funciones de más alto nivel.

====

[{topic}]
== *Librerías* = nuevos *problemas*

[role="incremental scatter"]
* *Diversidad* de librerías
* Librerías *independientes*
* Configuración *manual*
* *Carencia* de homogeneidad

[template="notesblock"]
====
*CHARLA (WHY):*

*Diversidad de librerías*

Esto que a priori es bueno, supone una nueva problemática para los proyectos
de desarrollo ya que en la mayoría de las ocasiones para desarrollar la
aplicación que necesitamos no nos es suficiente con usar una única librería
sino que necesitamos utilizar varias.

Utilizar varias librerías genera nueva problemática:

* Cada *librería es totalmente independiente*, con su propia configuración.
* Es necesaria una *configuración e instalación manual particulares* para cada
  librería
* Las librerías *no aportan una estructura* concreta a nuestros proyectos, por
  lo que ésta depende de cada desarrollador y nos podemos encontrar en la
  situación
  que cada proyecto y aplicación tiene una estructura diferente.

====

[{topic}]
== Framework = *productividad*

[role="incremental scatter"]
* *Estructura* y *configuración* homogénea
* Mecanimos *integrar* librerías
* *Estándares* = *colaboración*
* *Patrones* y buenas prácticas

[template="notesblock"]
====
*CHARLA (WHAT):*

Un framework es un conjunto de librerías cohesionadas que cubren aspectos
específicos de las necesidades de las aplicaciones, funciones de más alto
nivel que una única librería no cubre, se necesitan varias librerías para
poder dar una solución que genere mayor productividad:

*EJEMPLO: un framework de persistencia de objetos: integra librerías de log, el API JDBC, librerías para trabajar con archivos XML, etc.*

Los frameworks son sinónimo de productividad porque facilitan y
aceleran el proceso de desarrollo debido a:

* Define *una estructura de aplicación*, una *forma homogénea de configurar* y
  usar todas las librerías que integra.
* Especifica *mecanismos para integrar nuevas funciones* o librerías.
* *Facilita la colaboración*, ya que está todo más estandarizado y definido
  según el framework. Es un código menos personal.
* *Promueve el uso de patrones y buenas prácticas*, por ejemplo arquitectura
  MVC.
  .
  Ayudan al desarrollador a enfocarse principalmente en la lógica del negocio
  o el problema al cual debe dar solución con la aplicación.
====

[{topic}]
== *Frameworks* = nuevos *problemas*

[role="incremental scatter"]
* *Múltiples* en una aplicación
* *Aspectos concretos* [detail]#DI, MVC, seguridad, ...#
* Problema -> *Integrar frameworks*
* *Homogeneidad* limitada

[template="notesblock"]
====
*CHARLA (WHY):*

Sin embargo, aún con toda la productividad que proporcionan los frameworks,
los desarrolladores necesitan de varios frameworks y/o librerías para poder
satisfacer los requerimientos del proyecto.

Ocurre algo parecido a lo que ocurría con las librerías, las librerías agrupan
funciones de utilidad, los frameworks agrupan librerías que dan solución a un
aspecto concreto de una aplicación.

Por ejemplo, es fácil o habitual que nuestras aplicaciones web necesiten usar
*múltiples frameworks* que cada uno cubre un *aspecto funcional concreto* de 
la aplicación:

* Spring Framework, soluciona cómo se suministran los objetos a otros objetos
  en lugar de dejar que sean éstos quienes creen el propio objeto.
* Spring MVC, gestión de la vista y control de aplicaciones web.
* Spring Security, autenticación y autorización.
* CXF, desarrollo de servicios web
* JasperReports, desarrollo de informes
* Bootstrap, jQuery, etc.

Ahora el *problema no está en integrar librerías, sino en integrar frameworks*,
en configurarlos, en resolver colisiones de dependencias, etc etc etc

Aunque es cierto que los frameworks permiten que distintas aplicaciones tengan
la misma estructura y por tanto introduce *cierta homogeneidad* en los proyectos
de una organización, existe un problema: cada framework define su propia
estructura, por lo que si por cualquier circunstancia utilizamos frameworks
diferentes en distintas aplicaciones se pierde la homogeneidad en esos
proyectos.
====

[{topic}]
== Herramienta desarrollo = *productividad++*

[role="incremental scatter"]
* *Crear*, *integrar*, *configurar*, ...
* Patrones y *buenas prácticas++*
* *Focalizar++* en lógica de negocio
* *Homogeneidad++*

[template="notesblock"]
====
*CHARLA (WHAT):*

*Crear, integrar, configurar, ...*

Una herramienta de desarrollo es una aplicación para crear otras aplicaciones
basadas en varios frameworks y además integrar, configurar esos frameworks y
cómo se relacionan.

*Patrones y buenas prácticas++*

Las herramientas de desarrollo proporcionan patrones y buenas prácticas más
allá de cada framework o librería:

* El ciclo de vida va desde el análisis hasta el mantenimiento

*Focalizar++ en lógica de negocio*

Mayor porcentaje del tiempo dedicado a lógica de negocio ya que dedicamos el
tiempo de buscar cómo se configuran los frameworks, como se integran, etc
etc a programar.

*Homogeneidad++*

La homogeneidad no depende de cada framework, la define la herramienta de
desarrollo, pudiendo crear una estructura de proyectos única para
cualquier tipo de proyecto.

====

== Qué es gvNIX

[{statement}]
*gvNIX* es una *herramienta* de *desarrollo* rápido de aplicaciones web

[template="notesblock"]
====
*CHARLA (HOW):*

Pues bien, *gvNIX es una herramienta de desarrollo rápido de aplicaciones
web*. Es la herramienta de desarrollo que nos va a proporcionar todos los
beneficios de un herramienta de desarrollo para crear aplicaciones web.

====

[{topic}]
== *Beneficios* gvNIX

[role="incremental scatter"]
* *Libertad* evolutivo y correctivo
* *Uso* por *capas* [detail]#modelo, modelo-control, modelo-control-vista#
* Usuario gvNIX [detail]#*desarrollador* de aplicaciones#
* *Independencia* aplicaciones -> gvNIX

[template="notesblock"]
====
*CHARLA (HOW):*

Beneficios:

*Libertad evolutivo y correctivo*

* La evolucion de las aplicaciones no está bloqueda por la evolución de
  gvNIX. Ejemplos:
** Integrar una nueva funcionalidad en una aplicación no requiere que
   previamente se añada a gvNIX.
** Los estándares Java garantizan que las aplicaciones funcionarán en
   cualquier servidor de aplicaciones, sin embargo, estos estándares también
   evolucionan y aplicaciones que funcionaban perfectamente en versiones de
   servidores antiguas, por ejemplo JBoss 5, pueden no funcionar en versiones
   más recientes, por ejemplo JBoss 6. Hacer los cambios necesarios para que
   una aplicación funcione sobre nuevos servidores de aplicaciones no requiere
   que previamente se añada a gvNIX.
* Corregir incidencias en la aplicación no depende de gvNIX, se pueden
  corregir en la propia aplicación y posteriormente se reporta al proyecto
  gvNIX para incluir la mejora en futuras versiones.
** Un posible proceso de atención de incidencias o solicitud de mejoras que
   se puede seguir con gvNIX es:
   1. el usuario final informa de una incidencia, mejora, etc. en una
      aplicación al equipo de desarrollo de esa aplicación.
   2. el equipo de desarrollo da solución a la incidencia, pudiendo así dar
      mejores tiempos de respuesta que si se gestionara desde gvNIX.
   3. el equipo de desarrollo reporta la incidencia en el ámbito de gvNIX al
      proyecto gvNIX, incluyendola en la hoja de ruta y corrigiendola dentro
      de la siguiente versión de gvNIX.

*Uso por capas: modelo, modelo-control, modelo-control-vista*

gvNIX puede generar cualquiera de las capas de la arquitectura de la
aplicación. Se pueden utilizar gvNIX para generar cualquiera de las capas de
la aplicación: sólo modelo, modelo-controlador o modelo-vista-controlador.
De esta forma gvNIX ayuda en aquello que necesita el proyecto y permite
integrar otras tecnologías en una aplicación desarrollada con gvNIX. Por
ejemplo, se puede desarrollar una aplicación con gvNIX cuya vista esté
desarrollada con ExtJS.

*Usuario gvNIX: desarrollador de aplicaciones*

Diferencia explícita entre desarrolladores de aplicaciones como el usuario
tipo de gvNIX, y usuarios finales de la aplicaciones desarrolladas.

*Independencia aplicaciones -> gvNIX*

Importante es que al *no contener ningún componente en tiempo de ejecución*
no interfiere en el despliegue de las soluciones ni crea dependencias con el
producto final, de forma tal que resulta transparente para el despliegue en
producción.

====

[{topic}]
== Características

[role="incremental scatter"]
* *Multiplataforma* y fácil de instalar
* Generación *no-intrusiva* de código
* [detail]#Buenas prácticas desde# *Análisis*
* Proyectos *JEE* estándar
* *No* añade *dependencias* de componentes

[template="notesblock"]
====
*CHARLA (HOW):*

*Multiplataforma y fácil de instalar*.

gvNIX es fácil de instalar tanto como herramienta independiente que funciona
en Windows, Mac OSX, Linux o como herramienta integrada en un entorno de
desarrollo: STS o Eclipse.
Los únicos requerimientos son Java (6 o superior) SDK y Apache Maven 3. Una vez
instalados, se descarga la distribución de gvNIX, se descomprime y se añade
al PATH del sistema y lanzamos el entorno con el comando gvnix.

*Generación no-intrusiva de código*

Crea código en unidades de compilación separadas del código fuente creado
por los desarrolladores, de esta forma, la generación de código es
totalmente inocua porque independiza el ciclo de vida del código generado del
ciclo de vida del código mantenido por los desarrolladores.

*Buenas prácticas desde Análisis*

Todo proyecto de gvNIX comienza por un análisis del dominio del problema
plasmado sobre un modelo de clases que sirve como punto de partida del
proyecto.

A diferencia de herramientas de construcción como Maven que no dirigen hacía
un análisis previo.

*Proyectos JEE estándar*

Los proyectos creados con gvNIX son aplicaciones Java
que cumplen con el estándar JEE

*No añade dependencias de componentes*

gvNIX no añade ningún tipo de librería requerida en tiempo de ejecución.

====

== Arquitectura gvNIX

ifndef::backend-dzslides[]
image::gvnix-arquitectura-develtime.png[caption="Arquitectura de gvNIX",width="370"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-arquitectura-develtime.png[caption="Arquitectura de gvNIX"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

gvNIX ha sido implementado con lenguaje Java y sigue un modelo de
arquitectura orientado a componentes sobre plataforma OSGi en el que cada
funcionalidad que ofrece el framework es implementada como un componente o
add-on que colabora con el resto en las distintas tareas de generación.

Esta arquitectura es empleada en el desarrollo de grandes sistemas modulares
como, por ejemplo Eclipse, JBoss, Servicemix y un largo etcétera.

*¿Qué es OSGi?*

* OSGI (Open Services Gateway Initiative) es una capa sobre Java que permite
crear módulos o componentes que pueden interactuar entre sí en tiempo de
ejecución.
* OSGi intenta solventar los problemas del tradicional "classloader" de la
máquina virtual y de los servidores de aplicaciones Java (como JINI).
* En OSGI, cada componente tiene su propio classpath separado del resto de
classpath de los demás módulos.

OSGi ofrece:

* La principal característica, que aquellos que trabajeis con Eclipse ya
  conoceis es que OSGi proporciona un entorno que soporta el despliegue
  dinámico de componentes ("bundles" o módulos).
* La instalación, arranque, parada, actualización y desinstalación de bundles
  se realiza dinámicamente en tiempo de ejecución sin tener que detener por
  completo la plataforma.
* Es una arquitectura orientada a servicios.
* Los servicios pueden ser registrados y consumidos dentro de la VM.

Esta imagen ilustra la separación entre gvNIX y los proyectos y se aprecia como efectivamente es una herramienta que genera nuestras aplicaciones.

====

== Intérprete de comandos

ifndef::backend-dzslides[]
image::gvnix-shell-eclipse.png[caption="Intérprete de comandos",width="370"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-shell-eclipse.png[caption="Intérprete de comandos"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Desde el punto de vista de su uso, gvNIX está diseñado como
un intérprete de comandos interactivo *al estilo de Rails o de Grails*.

Para facilitar su uso tiene autocompletado de los comandos y ayuda contextual.
Además en todo momento nos mostrará solo los comandos que sean válidos y nos
dará pistas de cuál es la siguiente tarea a realizar si estamos un poco
perdidos.

En la imagen se ve cómo se interactúa con Roo.

Cada componente proporciona al shell un conjunto de comandos a través de los
cuales proporciona sus funciones al desarrollador, el cual decide si aplica o
no durante el proceso de desarrollo.

Además el propio framework proporciona sus propios comandos o funcionalidades
para facilitar el desarrollo. Los más destacados son:

* *help*: Muestra al desarrollador todos los comandos o funcionalidades
  disponibles.
* *hint*: Aconseja el siguiente paso posible en el proceso de desarrollo.

====

== Tecnología

ifndef::backend-dzslides[]
image::gvnix-arquitectura-runtime.png[caption="Arquitectura 3 capas",width="370"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-arquitectura-runtime.png[caption="Arquitectura 3 capas"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Habitualmente las aplicaciones web JavaEE se estructuran en tres capas: la
capa web, la de control y la de modelo del dominio.

La capa de dominio del problema suele contener una "sub-capa" de servicios
que ofrecen eso, servicios, al resto de capa e incluso a clientes remotos.
Tiene otra "sub-capa" de acceso a datos donde habitualmente tenemos
los DAOs, que se encargan de la persistencia de datos. Finalmente incluye las
clases que modelan las entidades del dominio, que se encargan no solo de
modelar el dominio sino también de la validación de sus datos e incluso su
serialización a JSON.

====

== Tecnología

ifndef::backend-dzslides[]
image::Java-web-fw-report.png[caption="Tecnología consolidada",width="370"]
endif::[]

ifdef::backend-dzslides[]
image::Java-web-fw-report.png[caption="Tecnología consolidada"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

¿Y que hay de la tecnología que incluye gvNIX en las aplicaciones? Pues es la
tecnología más utilizada en la actualidad. Spring MVC es el framework web
comunmente utilizado. El 40% de la población de estudio manifestó que
utilizaba Spring MVC.

Dos datos muy rápidos sobre las tecnologías que integra gvNIX en las
aplicaciones:

* Spring MVC es el framework para desarrollo web más utilizado

====

== Tecnología

ifndef::backend-dzslides[]
image::Java-tools-and-technologies-2014.jpg[caption="Enterprise Java 2014",width="370"]
endif::[]

ifdef::backend-dzslides[]
image::Java-tools-and-technologies-2014.jpg[caption="Enterprise Java 2014"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

*Por qué esta pila tecnológica?*

Las aplicaciones generadas por gvNIX están sobre una base
tecnológica asentada, robusta, moderna y sobre todo ampliamente utilizada a
nivel mundial lo que garantiza el futuro de las aplicaciones desarrolladas con
gvNIX.

Por tanto, *está maduro gvNIX*, claro, *lo contrario sería decir que Spring,
que jQuery, que Hibernate no están maduros*, pues como hemos visto gvNIX no es
un FW sino una herramienta de desarrollo que surge para solventar el problema
de la proliferación de tantos FW independientes.

====

== Aplicación con ExtJS

ifndef::backend-dzslides[]
image::gvnix-arquitectura-runtime-ExtJS.png[caption="Aplicación con ExtJS",width="370"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-arquitectura-runtime-ExtJS.png[caption="Aplicación con ExtJS"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Vamos a ver un ejemplo, ¿qué pasa si queremos usar una tecnología diferente
con gvNIX? Nada, podemos utilizar gvNIX para aquellas capas en las que nos
pueda ayudar y facilitar el desarrollo y aquellas capas que queremos una
tecnología diferente hacerlo a mano.

Una de las grandes ventajas de Spring Framework es que permite cambiar
fácilmente cualquiera de los elementos de una aplicación, no sólo los
soportados, sino que proporciona los mecanismos necesarios para integrar
cualquier librería o estándar nuevo en cualquiera de las versiones del
framework. A diferencia por ejemplo de entornos como Developer.

Por ejemplo, el echo que gvNIX no genere aplicaciones con ExtJS no implica que
no se pueda usar gvNIX, simplemente el desarrollador tendrá que incluir a
mano ExtJS en la aplicación generada con gvNIX.

Aún así el desarrollador obtendrá toda la productividad que le brinda gvNIX,
aunque evidentemente sólo en 2 capas de la aplicación.
====

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Análisis -> *Scaffolding*
* Seguridad *autorización* y *autenticación*
* Integración con *SAFE*
* Exportar/Importar *servicios web*
* *Pruebas* de integración y funcionales

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* *Informes*
* *Ingeniería inversa*
* Control de *concurrencia* [detail]#no intrusivo#
* *Auditoría* e *histórico* de cambios en bbdd

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Interfaz usuario *adaptativa* [detail]#(responsive UI)#
* Internacionalización
* Componentes avanzados: *tablas AJAX*, *lupa*
* Maestro -> detalle *multinivel*

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Monitorización *rendimiento* en producción
* *Asistente* para *filtros*
* Componente *geográfica*

[template="notesblock"]
====
*CHARLA (HOW):*

*Análisis -> Scaffolding*

Todo proyecto de gvNIX comienza por un análisis del dominio del problema
plasmado sobre un modelo de clases que sirve como punto de partida del
proyecto.

Una vez tenemos el análisis del modelo de entidades,
el scaffolding permite construir automáticamente
la aplicación que permite gestionar la información representada por ese modelo
de entidades.

*Seguridad autorización y autenticación*

* Instalar Spring Security
* Activar control de acceso
* Activar control de autorización
* Sistema de proveedores (Drivers) para conectar a distintos sistemas de
  gestión de usuarios: *SAFE*, *APLUSU*, ...
* Facilidad para incluir nuevos sistemas en caliente sin necesidad de estar
  preempaquetados en gvNIX.

*Exportar/Importar servicios web*

Publica servicios de la aplicación vía interfaz WebService.
gvNIX permite integrar la aplicación con procesos de negocio remotos
fácilmente. A partir de código Java con anotaciones JAX-WS o partir de
archivos WSDL, genera automáticamente toda la infraestructura necesaria para
recibir llamadas desde procesos externos.

También genera automáticamente clientes de servicios web simplemente indicando
la URL donde está publicado el WSDL genera las clases *Stub* en nuestra
aplicación que permitirá que el resto de clases puedan invocar esos servicios
remotos como si de llamadas a servicios locales se tratara.

*Pruebas de integración y funcionales*

Genera automáticamente pruebas de validación de código, tanto de integración 
con Junit como funcionales con Selenium.

*Informes*

Instala JasperReports para generar informes.

Cada informe es accesible desde el menú de la aplicación y genera un formulario previo para especificar los parámetros de filtrado.

Los informes son totalmente funcionales desde su creación, incluyendo la generación de la plantilla .jrxml para permitir una personalización cómoda y fácil.

*Ingeniería inversa de base de datos*

Permite crear el modelo completo de entidades Java de la aplicación vía la introspección de la base de datos del proyecto. Además, incrementalmente mantiene el modelo de entidades sincronizado con todos los cambios realizados en el modelo de datos.

*Control de concurrencia optimista no intrusivo*

En entornos multiusuario, como las aplicaciones web, es frecuente que dos usuarios accedan simultáneamente al mismo registro para editarlo. El control de concurrencia permite evitar que se pierdan los cambios del primero que guarde.

El patrón de control de concurrencia más aceptado en entornos web es el conocido
como control de concurrencia optimista. La forma más habitual de implementarlo es utilizar un campo de versión que debe incluirse en todas las tablas del modelo de datos.

En organizaciones públicas el modelo de datos sigue unas políticas de seguridad muy rigurosas y es frecuente que no se pueda añadir un nuevo campo de versión.

gvNIX proporciona una implementación del control de concurrencia optimista
*basado en el estado de los objetos*, igualmente efectivo pero no intrusivo.

*Auditoría de cambios en base de datos*

Añade soporte a la aplicación para hacer auditoría de cambios en datos de las
entidades del modelo: registrar quien y cuándo crea o modifica una instancia,
o en términos de base de datos quien y cuándo modifica un registro

*Histórico de cambios de base de datos*

Esta funcionalidad almacena todos los cambios sufridos por las entidades
auditadas de forma que sea posible identificar qué, quién y cuándo se
produjeron, incluyendo las eliminaciones de los registros.

*Interfaz usuario adaptativa (responsive UI)*

Integran frameworks de desarrollo web en la aplicación para generar la vista
con una estructura HTML5 y CSS3 adaptativa, es decir, automáticamente se
adaptan para su visualización desde múltiples dispositivos: tabletas, móviles,
portátiles, PCs ...

Ademá, estos frameworks de desarrollo utilizan estándares web de tal forma que
se sientan las bases de sitios web accesibles para personas que utilizan
tecnologías de apoyo para navegar.

*I18n*

Permite añadir soporte para nuevos idiomas en el proyecto. Al incluir un nuevo
idioma, se añaden en la aplicación de forma automática y infraestructura
necesaria y los textos traducidos a dicho idioma.

*Componentes avanzados: tablas AJAX, lupa*

*Datatables*

Integra componentes de tablas más dinámicas y funcionales: paginación,
búsqueda global, filtrado por columna, ordenación, diversas fuentes de
datos: AJAX, DOM, etc; visualización en modo registro, edición en línea,
edición y borrado múltiple, conjunto predefinido de operaciones,
registro creado a primera posición, selección siempre visible.

*Lupa*

Permite utilizar componentes de tipo lupa en las aplicaciones. Gracias a estos
componentes, podemos buscar registros de forma sencilla de campos relacionados
sin tener que visualizar todos los datos en un desplegable.

*Maestro -> detalle multinivel*

Permite definir patrones de visualización sobre entidades y sus relaciones:
permitiendo cualquier combinación [maestro-tabular | maestro-registro] con
[detalle-tabular | detalle-registro], sin límite en el número de relaciones
tanto directas como indirectas.

*Monitorización rendimiento en producción*

Integra un sistema de monitorización para aplicaciones web en producción.

Se crea la infraestructura necesaria para registrar tiempos de ejecución de
los distintos elementos de la aplicación: generación de vista, consultas SQL,
ejecución de métodos, petición HTTP.

Además se crea una página desde donde podemos ver estadísticas de los
datos recopilados.

*Asistente para filtros*

Los sistemas de filtrado de datos de la tabla permiten no sólo comparar texto
plano sino que permite definir operaciones de filtrado como *CONTIENE()*,
*>=*, *FECHA()*, etc

Dado que es complicado acordarse de todas las operaciones, al activar el
filtrado por columna se integra automáticamente un asistente que permite al
usuario elegir la operación de filtrado por columna.

====

== ¿Qué es la "Componente geográfica"?

ifndef::backend-dzslides[]
image::geoportal-problem.png[caption="Componente Geo",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::geoportal-problem.png[caption="Componente Geo"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Históricamente la explotación de datos geográficos y alfanuméricos
se ha realizado desde distintas aplicaciones.

La explotación de datos geográficos se realiza desde una aplicación,
por ejemplo una aplicación de escritorio, a la que accede un perfil de
usuarios expertos en materia geográfica.

Por otro lado, la explotación de datos alfanuméricos se realiza desde 
otra aplicación, por ejemplo una aplicación web, a la que accede un perfil 
de usuarios sin conocimientos en materia geográfica.

La problemática radica en que un mismo bloque de información, como por ejemplo
datos de una calle, debe ser mantenida desde distintas aplicaciones
simplemente porque las aplicaciones de gestión de datos alfanuméricos no
soportan geometrías. Siguiendo con el ejemplo anterior, el nombre de la calle
y el ancho se actualizarían por un usuario desde una aplicación y
la geometría se actualizaría por un usuario especializado desde gvSIG
Desktop.
====

== Beneficios de gvNIX Geo

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-field.png[caption="Gestión calles",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-field.png[caption="Gestión calles"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

gvNIX permite desarrollar rápidamente aplicaciones de gestión de información
alfanumérica y geográfica, con las que los usuarios podrán mantener y explotar
la información de forma homogénea y desde una sóla aplicación, sin necesidad
de hacer uso de aplicaciones especializadas.

*Consiguiendo:*

* Mayor productividad: se finalizan los trabajos más rápidamente ya que un
  único usuario gestiona la información y no se requiere la intervención de
  diversos usuarios.
* Mayor eficiencia: ya que cada usuario se especializa en su labor.

Es un nuevo paradigma para trabajar con información Geo, similar a como lo son
las IDE frente al concepto clásico de los SIG.

====

[{topic}]
== Tecnología Geo: *Modelo de datos*

[role="incremental"]
* Soporte *BBDD espaciales* [detail]#PostgreSQL con *PostGIS*, Oracle con *Spatial*#
* *Campos* geográficos *vectoriales*
* *Consultas* a BBDD con filtros *espaciales*

[template="notesblock"]
====
*CHARLA (HOW):*

*Soporte BBDD espaciales*

Configurar soporte para BBDD espaciales. Ejemplos de ello son: PostgreSQL
con PostGIS, Oracle con Spatial, etc. que permiten unir datos
alfanuméricos habituales con nuevos campos geométricos que representen la
localización y forma de los datos. Por ejemplo, si tenemos una tabla con las
ciudades de un país, tendremos datos como el nombre, el número de habitantes,
etc. y por otro lado podemos tener un punto geográfico que indique la posición
de la ciudad en el mapa, o un polígono con la forma del término municipal.

*Incorporar campos geográficos vectoriales* como un dato más en el modelo
de datos de una aplicación, integrando y configurando las librerías
necesarias para ello.

*Consultas a BBDD con filtros espaciales*

Soporte para consultas a BBDD con filtros espaciales. Es decir, poder buscar
datos no sólo por sus valores alfanuméricos, sino también por sus
características geográficas: elementos que estén cerca de una localización,
dentro de un área determinada, etc.
====

[{topic}]
== Tecnología Geo: *Capa de presentación*

[role="incremental"]
* *Automáticamente* genera la *gestión* de información *geolocalizada*
* *Edición* geometrías
* *Generación* de *geoportales*
* *Integración* tecnología soporte *geo*

[template="notesblock"]
====
*CHARLA (HOW):*

*gvNIX genera automáticamente páginas para explotación de datos*, listado,
búsqueda, creación y edición de datos alfanuméricos y además incorpora la
visualización sobre un mapa de estos mismos datos. Por ejemplo, si tenemos
un listado de ciudades que se muestran sobre una tabla, se podría incorporar
también un mapa en el que se muestre la localización de estas ciudades.

*Edición geometrías*

Permite la edición de la localización de elementos. Incorpora a los
formularios de creación y edición de datos que genera gvNIX el poder
establecer la localización del dato que se está editando mediante la
selección de un punto sobre un mapa.

*Generación de geoportales*

Cualquier aplicación gvNIX puede incorporar
un geoportal en el que se muestren todos los datos que se gestionan desde la
aplicación como diferentes capas, con opciones de búsqueda, activación,
etc., así como integración con el resto de páginas de la aplicación:
herramienta de edición que al seleccionar un elemento sobre el mapa, nos
lleva al formulario de edición de dicho elemento.

*Integración tecnología soporte geo*

gvNIX permite integrar y combinar distintos frameworks y librerías de tal
forma que cualquier desarrollador será perfectamente capaz
de desarrollar aplicaciones de gestión con componente geográfica.

====

[{topic}]
== *Hoja de ruta* Geo

[role="incremental scatter"]
* Generar *mapa de referencia*
* *Mostrar* las *coordenadas* del ratón
* *Escala* gráfica y numérica
* Soporte para crear *grupos de capas*
* *Ordenación* de capas
* *Gestión* de capas por *usuario*
* Gestión de *transparencia*
* *Imprimir* mapas
* Buscador por *callejero*

[template="notesblock"]
====
*CHARLA (HOW):*

*Generar mapa de referencia*

Permite tener una vista completa del mapa siempre, en el que se muestra un rectángulo con el bounding box de la vista central. Como funcionalidad añadida, además de visualización se podría permitir mover el encuadre de la vista central sobre el propio mapa de referencia.

*Mostrar las coordenadas del ratón*

Ver las coordenadas de mapa sobre las que está el puntero de ratón en cada momento.

*Escala gráfica y numérica*

Visualizar la escala en función del nivel de zoom actual.

*Ordenación de capas*

Permitir al usuario cambiar el orden de las capas

*Gestión de capas por usuario*

Permitir al usuario añadir o quitar capas, bien de una lista predefinida en una opción del geoportal, bien con una opción que le permita especificar directamente la URL. 

*Gestión de transparencia*

Modificar el nivel de transparencia de una capa.

*Imprimir mapas*

Imprimir la vista actual, o generar un PDF.

*Buscador por callejero*

Herramienta de buscador por callejero: escribimos un nombre de calle, nos muestra una lista de coincidencias y al elegir una nos cambia el encuadre para mostrar la calle. Quizás se pueda hacer algo más avanzado o usable.

====

[{topic}]
== Sostenibilidad

[role="incremental"]
* *Software libre* en empresas
* Fortaleza = *múltiples contribuidores*
* Comunidad de desarrollo [detail]#empresas, organizaciones, universidades#
* Cooperación = *mayor calidad*
* Sostenibilidad <- facilitar y gestionar la cooperación

[template="notesblock"]
====
*CHARLA (HOW):*

*Software libre en empresas*

Es innegable el papel que está jugando el software libre en el ámbito de la
gestión de empresas y administraciones públicas. Hasta hace unos pocos años,
se consideraba una rareza y aventurarse en un proyecto Open Source en la
empresa o en una administración pública, era cuanto menos, bastante
arriesgado. Hoy día, estos proyectos, en algunos ámbitos, están desplazando
a sus homólogos de software privativo.

*Fortaleza = múltiples contribuidores*

Una de las fortalezas mayores desde nuestro punto de vista es la posibilidad
de *escalar el producto en base a las aportaciones de múltiples
contribuidores*, y que en el software privativo queda reducido a los
recursos de los que dispone la empresa propietaria.

*Comunidad de desarrollo*

Estos colaboradores constituyen la *comunidad de desarrollo*, cuyo objetivo es
aglutinar grupos de personas, empresas, organizaciones, universidades e
individuos con un objetivo y beneficio común sobre la base de promover el
acceso y distribución de una herramienta software permitiendo la libertad de
su uso, estudio, copia, modificación y redistribución a todo aquel que lo
desee.  Empresas que entorno al desarrollo de un modelo de negocio basado en
el conocimiento compartido, ve que el hecho de que las herramientas que
utilizan para la producción de las soluciones que ofrece, sean cada vez más
potentes, le ofrece más oportunidades. De ahí que a esas empresas y
organizaciones les puede interesar que se potencie gvNIX, etc.

*Cooperación = mayor calidad*

La *cooperación* entre estos grupos de personas y organizaciones en todos
los ámbitos de la producción del software (usuarios, desarrolladores,
documentadores, testers, traductores, ...) permite generar las sinergias
necesarias para conseguir una *mejora sustancial de la calidad del
software*, así como de una mayor difusión y sostenibilidad en el tiempo, y
primando el beneficio de la sociedad sobre cualquier otro.

*Sostenibilidad <- facilitar y gestionar la cooperación*

Esa *sostenibilidad* pasa por potenciar, facilitar y dirigir todas esas
colaboraciones y aportaciones de empresas y organizaciones que, por afinidad
con los intereses en el modelo de negocio, quieran partiendo de gvNIX
enriquecerlo.

====

[{topic}]
== Crear las condiciones para un proyecto sostenible

[role="incremental scatter"]
* Potenciar distribuciones *personalizadas*
* Fomentar la *cooperación*
* *Internacionalización*
* Entidad gestora

[template="notesblock"]
====
*CHARLA (HOW):*

Para facilitar y dirigir todas las colaboraciones y aportaciones de empresas y
organizaciones que hacen falta 4 elementos fundamentales:

*Potenciar distribuciones personalizadas*

El propio gvNIX incluye el soporte necesario para personalizar la distribución
pública, de tal forma que cada organismo puede ajustar, mejorar o
incluir nuevas funcionalidades a gvNIX consiguiendo una mayor eficiencia y
productividad en sus desarrollos sin perder los beneficios de la contribución
al código fuente de la distribución pública que realizan los diferentes
miembros de la comunidad.

Desde esta visión, generar y potenciar una distribución pública repercutirá en
el beneficio de toda la comunidad, tanto aquellos que utilicen la distribución
pública como aquellos que utilicen una distribución personalizada, ya que 
todos los complementos de interés general contribuidos a la distribución 
pública estarán automáticamente y por defecto incluidos en cualquier 
distribución personalizada.

*Fomentar la cooperación*

Más allá de los conceptos teóricos, filosóficos y jurídicos, un proyecto
software se desarrolla gracias a una serie de herramientas técnicas: gestores
de proyectos, control de versiones de código, wikis, listas de correo,
gestores de errores o bugs, etc.; que facilitan la colaboración simultánea,
deslocalizada y la coordinación de los miembros.

*Internacionalización*

Trabajar para que el proyecto pueda expandirse a distintas regiones, como
forma de crecimiento de la comunidad de desarrollo y así conseguir involucrar
a más organizaciones y empresas para ganar en calidad, desarrollo del
producto, etc.

*Entidad gestora*

Una *entidad gestora del proyecto*, que vele por los intereses del proyecto, que
defina y modere el modelo de sostenibilidad, que organice la comunidad de
desarrollo, la difusión, los recursos del proyecto, etc.

====

[{topic}]
== Casos de uso

[role="incremental"]
* Aplicaciones de gestión *homogéneas*
* Migración a *entorno web*
* *Integración* con procesos de negocio
* Sistemas mixtos *móvil-web*
* Gestión *datos geográficos*
* *Portlets* Liferay

[template="notesblock"]
====
*CHARLA (HOW):*

*Aplicaciones de gestión*

Las grandes organizaciones están en constante evolución, todos los días surgen
nuevas necesidades y requerimientos que deben cubrirse con nuevas
aplicaciones. gvNIX ofrece una infraestructura común para los desarrollos
propios y externos, garantizando que todos los proyectos son similares para
facilitar el mantenimiento y la evolución.

* Aplicaciones de gestión medias-grandes con un alto número de accesos
concurrentes vía web.
* Aplicaciones de gestión con gran volumen de datos.

*Migración de aplicaciones a entorno web*

La evolución tecnológica durante años hace que en las organizaciones exista
gran diversidad de aplicaciones que por diferentes motivos carecen de
mantenimiento.

gvNIX es un entorno a la medida de cualquier perfil que permite migrar
aplicaciones de gestión de datos rápidamente.

Ejemplos:

* Gestión de acuses de recibo electrónicos de la CITMA
* Gestión de aplicaciones y usuarios de la CITMA
* Aplicación web Explorador de servicios web
* Gestión de proyectos de la CITMA
* Gestión de sentencias judiciales del CITMA
* Gestión de Terceros de la CITMA
* Gestión de catálogos de obras de arte para el museo de Alzira
* Gestión de recursos agrícolas en la Florida Universitaria (XL)
* Gestión de Caza y Pesca (Peyca)
* gvCarrera: 1ra fase desarrollada en 4 semanas (análisis funcional incluido)

*Integración de aplicaciones en procesos de negocio*

Las organizaciones acumulan diversidad de procesos en un entorno tecnológico
heterogéneo: cliente/servidor, aplicaciones web, servicios SOA, etc.

gvNIX permite conectar entre sí distintas aplicaciones con distintas
tecnologías con tiempos y costes de desarrollo reducidos.

Ejemplos:

* Generación de acuses de recibo electrónicos de la CITMA
* Servicios web de Mastín: Integración entre las aplicaciones Serpre y Mastín
  de la CITMA
* Gestión y recepción de información de sistemas de tiempo real RFID (M).

*Sistemas mixtos móvil-web*

Poner arquitectura medioambiente

Ejemplos:

* Gestión de denuncias Medio Ambientales

*Aplicaciones de gestión de datos con componente geo*

Proof geo

Ejemplos:

* *gvSIG Roads DIVAL*: Gestión del Mantenimiento Integral de Carreteras de la
  Diputación de Valencia.
* *GeoTIC*: Geoportal de los recursos TIC de la Generalitat Valenciana en el
  territorio, incluyendo recursos de telecomunicaciones, microinformática y 
  sistemas.

*Aplicaciones incrustadas en portales Liferay*

Ejemplos:

* Gestión de inmuebles en un entorno de portlets Liferay para Cúspide Inmobiliaria

====

[role="topic recap"]
== Demo: Entidades

ifndef::backend-dzslides[]
image::petclinic-uml.png[caption="Análisis del dominio",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::petclinic-uml.png[caption="Análisis del dominio"]
endif::[]

[role="topic recap"]
== Demo: Funcional

ifndef::backend-dzslides[]
image::../wireframes/wireframes.png[caption="Análisis funcional",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::../wireframes/wireframes.png[caption="Análisis funcional"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

El objetivo de esta demo es ver un ejemplo de aplicación que incluye
funcionalidades que se podrán desarrollar con la nueva versión de
gvNIX, la 1.4 que saldrá en noviembre de este año:

* Interfaz adaptativo (desde 1.3)
* Patrones de pantallas (desde 1.3)
* Asistente para filtros (1.4)
* Monitorización rendimiento en producción (1.4)
* Componente geográfica (1.4)

Aunque con gvNIX se pueden desarrollar aplicaciones siguiendo distintos
métodos, el que mejor se ajusta a las características de gvNIX es DDD o
*Desarrollo Dirigido por el Dominio*:

* Un proyecto de gvNIX debería comenzar por un análisis del dominio
  y un análisis funcional, de tal forma que sobre las pantallas funcionales
  pueda concretarse con el usuario final el flujo y organización funcional de
  las mismas y seamos capaces de revisar el análisis del dominio para que se
  ajuste a los requerimientos validados con el usuario sobre las pantallas
  funcionales.
* Si la aplicación tiene interfaz de usuario, se genera automáticamente y
  se ajusta la interfaz a las especificaciones de requerimientos.
* A continuación se inicia un proceso evolutivo donde se codifica la lógica
  de negocio y las pruebas de integración para hacer crecer el sistema hasta tener
  la aplicación final.

La aplicación demo es para *gestión de una clínica veterinaria*. Los usuarios
de la aplicación son trabajadores de una clínica que, en el desempeño de su
trabajo, necesitan ver y gestionar información de veterinarios, agenda de
visitas, clientes y sus mascotas.

Veremos cómo se ajusta el interfaz automáticamente al dispositivo, los
patrones de pantallas y cómo se unen los datos alfanuméricos con los
geográficos.

Este diagrama de clases representa un modelo simplificado del dominio del
problema de una clínica veterinaria.

====

[role="topic recap"]
== {gvnixsite}

[{middle}]
image::logo_gvNIX.png[height="120"]

== \\

[{middle}]

http://creativecommons.org/licenses/by-sa/3.0/es/[Este obra está bajo una licencia de Creative Commons Reconocimiento-CompartirIgual 3.0 España.]


////

////

