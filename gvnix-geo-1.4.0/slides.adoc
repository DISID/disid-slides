//
// Build the presentation
//
// dzslides with embedded assets:
//
//   $ asciidoc -a data-uri slides.adoc
//
// HTML5 (print):
//
//   $ asciidoc -b html5 -o outline.html slides.adoc
//
// PDF:
// 
//   $ dzslides2pdf.rb slides.adoc
//
//   PDF conversion requires: ruby, qt4-make, ruby-qt4, ruby-qt4-webkit, 
//   capybara, capybara-webkit,
//
 
= **gvNIX** - Desarrollo rápido de geoportales para visualización y gestión de datos 
v1.1, 26 nov 2014
:title: gvNIX - Desarrollo rápido de geoportales para visualización y gestión de datos
:description: These slides are a strategic overview to gvNIX Geo component
support included in release 1.4 for 10 international gvSIG Conference
:copyright: CC BY-NC-SA 3.0
:corpsite: www.disid.com
:gvnixsite: www.gvnix.org
:imagesdir: images
:linkcss!:
:source-highlighter: highlightjs
:backend: dzslides
:dzslides-style: gvsig-jornadas
:dzslides-aspect: 4-3
:dzslides-transition: fade
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: monokai
:syntax: no-highlight

////

////

[template="notesblock"]
====
*CHARLA (INTRODUCCIÓN):*

Presentación: Mario Martínez Sánchez, Director de Proyectos en DISID

En esta charla explicaremos qué es la herramienta de desarrollo gvNIX.

Haremos un repaso de las funcionalidades que nos ofrece para el 
desarrollo de aplicaciones web con componente geográfica.

Veremos cómo incluir datos georeferenciados en una aplicación desarrollada con gvNIX.

====

[{intro}]
== *Frameworks*

[{topic}]
== *Frameworks*

[role="incremental scatter"]
* Conjunto de librerías cohesionadas
* *Múltiples* en una aplicación
* *Aspectos concretos* [detail]#DAO, MVC, GEO, ...#
* Problema -> *Integrar frameworks*
* *Homogeneidad* limitada

[template="notesblock"]
====
*CHARLA (WHY):*

Un framework es un conjunto de librerías cohesionadas que cubren aspectos
específicos de las necesidades de las aplicaciones, funciones de más alto 
nivel que una única librería no cubre, se necesitan varias librerías para
poder dar una solución que genere mayor productividad:

*EJEMPLO: un framework de persistencia de objetos espaciales:
integra librerías de log, el API JDBC, Hibernate Spatial, Postgis, etc.*

Sin embargo, aún con toda la productividad que proporcionan los frameworks,
los desarrolladores necesitan de varios frameworks y/o librerías para poder 
satisfacer los requerimientos del proyecto.

Ocurre algo parecido a lo que ocurre con las librerías, las librerías agrupan
funciones de utilidad, los frameworks agrupan librerías que dan solución a un
aspecto concreto de una aplicación.

Por ejemplo, es fácil o habitual que nuestras aplicaciones web necesiten usar 
varios de los siguientes frameworks:

* Spring Framework.
* Hibernate Spatial, Postgis, etc.
* Spring MVC
* Bootstrap, jQuery, etc.
* Leaflet, JTS (Java Topology Suite), etc.
 
El problema está en integrar frameworks, en configurarlos,
en resolver colisiones de dependencias, etc etc etc

Aunque es cierto que los frameworks permiten que distintas aplicaciones tengan
la misma estructura y por tanto introduce cierta homogeneidad en los proyectos
de una organización, existe un problema: cada framework define su propia
estructura, por lo que si por cualquier circunstancia utilizamos frameworks
diferentes en distintas aplicaciones se pierde la homogeneidad en esos
proyectos.
====

[{intro}]
== *Herramienta desarrollo*

[{topic}]
== Herramienta desarrollo = *productividad*

[role="incremental scatter"]
* *Crear*, *integrar*, *configurar*, ...
* Patrones y *buenas prácticas*
* *Focalizar* en lógica de negocio
* *Homogeneidad*

[template="notesblock"]
====
*CHARLA (WHAT):*

* Una herramienta de desarrollo es una aplicación para crear otras aplicaciones 
  basadas en varios frameworks y además integrar, configurar esos frameworks y 
  cómo se relacionan.
* Las herramientas de desarrollo proporcionan patrones y buenas prácticas más
  allá de cada framework o librería:
- El ciclo de vida va desde el análisis hasta el mantenimiento
* Mayor porcentaje del tiempo dedicado a lógica de negocio ya que dedicamos el
  tiempo de buscar cómo se configuran los frameworks, como se integran, etc
  etc a programar.
* La homogeneidad no depende de cada framework, la define la herramienta de
  desarrollo, pudiendo crear una estructura de proyectos única para 
  cualquier tipo de proyecto.

====

[{intro}]
== *gvNIX*

== Qué es gvNIX

[{statement}]
*gvNIX* es una *herramienta* de *desarrollo* rápido de aplicaciones web

[template="notesblock"]
====
*CHARLA (HOW):*

Pues bien, *gvNIX es una herramienta de desarrollo rápido de aplicaciones
web*. Es la herramienta de desarrollo que nos va a proporcionar todos los
beneficios de un herramienta de desarrollo para crear aplicaciones web.

Así mismo, nos va a facilitar la inclusión de un componente geográfico
para georeferenciar la información. 

Las aplicaciones generadas por gvNIX están sobre una base
tecnológica asentada, robusta, moderna y sobre todo ampliamente utilizada a
nivel mundial lo que garantiza el futuro de las aplicaciones desarrolladas con
gvNIX.

La evolucion de las aplicaciones no está bloqueda por la evolución de
gvNIX. El integrar una nueva funcionalidad en una aplicación no requiere que 
previamente se añada a gvNIX.
   
====

[{topic}]
== Características

[role="incremental scatter"]
* *Multiplataforma* y fácil de instalar
* Generación *no-intrusiva* de código
* [detail]#Buenas prácticas desde# *Análisis*
* Proyectos *JEE* estándar
* *No* añade *dependencias* de componentes

[template="notesblock"]
====
*CHARLA (HOW):*

* *Multiplataforma y fácil de instalar*.
  gvNIX es fácil de instalar tanto como herramienta independiente que funciona
  en Windows, Mac OSX, Linux o como herramienta integrada en un entorno de
  desarrollo: STS o Eclipse.
  Los únicos requerimientos son Java (6 o superior) SDK y Apache Maven 3. Una vez
  instalados, se descarga la distribución de gvNIX, se descomprime y se añade
  al PATH del sistema y lanzamos el entorno con el comando gvnix.
* *Generación no-intrusiva de código*
  Crea código en unidades de compilación separadas del código fuente creado
  por los desarrolladores, de esta forma, la generación de código es 
  totalmente inocua porque independiza el ciclo de vida del código generado del
  ciclo de vida del código mantenido por los desarrolladores.
* *Buenas prácticas desde Análisis*
  Todo proyecto de gvNIX comienza por un análisis del dominio del problema
  plasmado sobre un modelo de clases que sirve como punto de partida del
  proyecto.
  A diferencia de herramientas de construcción como Maven que no dirigen hacía
  un análisis previo.
* *Proyectos JEE estándar*
  Los proyectos creados con gvNIX son aplicaciones Java
  que cumplen con el estándar JEE
* *No añade dependencias de componentes*
  gvNIX no añade ningún tipo de librería requerida en tiempo de ejecución.

====

[{topic}]
== Intérprete de comandos

ifndef::backend-dzslides[]
image::gvnix-shell-eclipse.png[width="700"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-shell-eclipse.png[width="700"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Desde el punto de vista de su uso, gvNIX está diseñado como 
un intérprete de comandos interactivo. 

Para facilitar su uso tiene autocompletado de los comandos y ayuda contextual. 
Además en todo momento nos mostrará solo los comandos que sean válidos y nos 
dará pistas de cuál es la siguiente tarea a realizar si estamos un poco 
perdidos.

En la imagen se ve cómo se interactúa con Roo.

Cada componente proporciona al shell un conjunto de comandos a través de los
cuales proporciona sus funciones al desarrollador, el cual decide si aplica o
no durante el proceso de desarrollo.

Además el propio framework proporciona sus propios comandos o funcionalidades
para facilitar el desarrollo. Los más destacados son:

* *help*: Muestra al desarrollador todos los comandos o funcionalidades 
  disponibles.
* *hint*: Aconseja el siguiente paso posible en el proceso de desarrollo.

====

[{intro}]
== *Funcionalidades de gvNIX*

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Análisis -> *Scaffolding*
* Seguridad *autorización* y *autenticación*
* Exportar/Importar *servicios web*
* *Pruebas* de integración y funcionales

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* *Informes*
* *Ingeniería inversa*
* Control de *concurrencia*
* *Auditoría* e *histórico* de cambios en bbdd

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Interfaz usuario *adaptativa* [detail]#(responsive UI)#
* Internacionalización
* Componentes avanzados: *tablas AJAX*, *lupa*
* Maestro -> detalle *multinivel*

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Monitorización *rendimiento* en producción
* *Asistente* para *filtros*
* Componente *geográfica*: geoportales

[template="notesblock"]
====
*CHARLA (HOW):*

*Análisis -> Scaffolding*

Todo proyecto de gvNIX comienza por un análisis del dominio del problema
plasmado sobre un modelo de clases que sirve como punto de partida del
proyecto.

Una vez tenemos el análisis del modelo de entidades,
el scaffolding permite construir automáticamente
la aplicación que permite gestionar la información representada por ese modelo
de entidades.

*Seguridad autorización y autenticación*

* Instalar Spring Security

Activa un control de acceso y de autorización.

*Exportar/Importar servicios web*

Publica servicios de la aplicación vía interfaz WebService.
Genera automáticamente toda la infraestructura necesaria para
recibir llamadas desde procesos externos.
También genera automáticamente clientes de servicios web.

*Pruebas de integración y funcionales*

Genera automáticamente pruebas de validación de código, tanto de integración con Junit 
como funcionales con Selenium.

*Informes*

Instala JasperReports para generar informes.

*Ingeniería inversa de base de datos*

gvNIX proporciona una implementación del control de concurrencia optimista 
*basado en el estado de los objetos*, igualmente efectivo pero no tan intrusivo
como el método clásico de un campo de versión que debe incluirse en todas las tablas del modelo de datos.

*Auditoría de cambios en base de datos*

Añade soporte a la aplicación para hacer auditoría de cambios en datos de las
entidades del modelo.

*Histórico de cambios de base de datos*

Esta funcionalidad almacena todos los cambios sufridos por las entidades 
auditadas.

*Interfaz usuario adaptativa (responsive UI)*

Integran frameworks de desarrollo web en la aplicación para generar la vista 
con una estructura HTML5 y CSS3 adaptativa.

*I18n*

Permite añadir soporte para nuevos idiomas en el proyecto.

*Componentes avanzados: tablas AJAX, lupa*

*Datatables*

Integra componentes de tablas más dinámicas y funcionales.

*Lupa*

Permite utilizar componentes de tipo lupa en las aplicaciones.

*Maestro -> detalle multinivel*

Permite definir patrones de visualización sobre entidades y sus relaciones.

*Monitorización rendimiento en producción*

Integra un sistema de monitorización para aplicaciones web en producción.

*Asistente para filtros*

Los sistemas de filtrado de datos de la tabla permiten definir operaciones
de filtrado complejas por columna mediante un asistente.

====

[{intro}]
== *Geoportales*

[{topic}]
== Geoportales

ifndef::backend-dzslides[]
image::console-screens.png[width="570"]
endif::[]

ifdef::backend-dzslides[]
image::console-screens.png[width="500"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Cada vez son más las áreas del saber que requieren el uso de datos geoespaciales
para cumplir con mayor acierto sus procesos, como la gestión pública, gestión
medioambiental, ingeniería, entre otras, por lo que existe hoy en día una
creciente necesidad de aplicaciones web que requieren compartir e integrar
datos georeferenciados con datos alfanuméricos para realizar diferentes tipos
de análisis espacio-territoriales y ayudar en la toma de decisiones.

====

[{topic}]
== Modelo de entidades

ifndef::backend-dzslides[]
image::diagrama-uml-callejero.png[width="300"]
endif::[]

ifdef::backend-dzslides[]
image::diagrama-uml-callejero.png[width="300"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Aunque con gvNIX se pueden desarrollar aplicaciones siguiendo distintos
métodos, el que mejor se ajusta a las características de gvNIX es DDD o
*Desarrollo Dirigido por el Dominio*:

* Un proyecto de gvNIX debería comenzar por un análisis del dominio 
  y un análisis funcional, de tal forma que sobre las pantallas funcionales
  pueda concretarse con el usuario final el flujo y organización funcional de
  las mismas y seamos capaces de revisar el análisis del dominio para que se
  ajuste a los requerimientos validados con el usuario sobre las pantallas 
  funcionales.
* Si la aplicación tiene interfaz de usuario, se genera automáticamente y 
  se ajusta la interfaz a las especificaciones de requerimientos.
* A continuación se inicia un proceso evolutivo donde se codifica la lógica 
  de negocio y las pruebas de integración para hacer crecer el sistema hasta tener 
  la aplicación final.

La aplicación de ejemplo representa la *gestión de un pequeño callejero*. 
cuyos usuarios necesitan ver y gestionar información de edificios y calles.

Veremos cómo cómo se unen los datos alfanuméricos con los geográficos
y cómo se representan en el geoportal.

Este diagrama de clases representa un modelo muy simplificado del dominio
del problema de una callejero.

====

[{topic}]
== Campo geográfico tipo texto

ifndef::backend-dzslides[]
image::callejero-field-geo.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-field-geo.png[width="700"]
endif::[]

[{topic}]
== Campo geográfico tipo mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-field.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-field.png[width="700"]
endif::[]

[{topic}]
== Incluir mapa del geoportal

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-controller.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-controller.png[width="700"]
endif::[]

[{topic}]
== Mostrar entidades en el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-entity-all.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-entity-all.png[width="700"]
endif::[]

[{topic}]
== Seleccionar entidades en el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-entity-all-filter.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-entity-all-filter.png[width="700"]
endif::[]

[{topic}]
== Gestión entidades desde el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-entity-all-edit.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-entity-all-edit.png[width="700"]
endif::[]

[{topic}]
== Marcar entidades en el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-datatables-add-selected.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-datatables-add-selected.png[width="700"]
endif::[]

[{topic}]
== Filtrar entidades en el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-datatables-add-filtered.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-datatables-add-filtered.png[width="700"]
endif::[]

[{topic}]
== Incluir nuevas capas en el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-tilelayer.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-tilelayer.png[width="700"]
endif::[]

[{topic}]
== Incluir herramientas en el mapa

ifndef::backend-dzslides[]
image::callejero-web-mvc-geo-tool-measure.png[width="700"]
endif::[]
ifdef::backend-dzslides[]
image::callejero-web-mvc-geo-tool-measure.png[width="700"]
endif::[]

[template="notesblock"]
====

No estamos hablando de que nuestra aplicación integre un plugin Javascript que
muestre un *mapita de Google Maps* donde geoposicionamos información concreta de
la aplicación, estamos hablando de:

* Edición de datos de tipo geofráfico
* Cruzar información de múltiples entidades en un mapa
* Poder filtrar registros del mapa
* Mostrar en el mapa sólo registros seleccionados
* Generar listado de capas disponibles
* Añadir fácilmente nuevas capas:
- Datos de entidades
- open street map,
- GVA IDE
- ...
* Habilitar herramientas de mapas y permitir crear nuevas herramientas:
  medición, zoom, escala, ...
* Accesible desde cualquier dispositivo: tableta, móvil, PC ...

Qué proporciona gvNIX a los desarrolladores que deseen incorporar estas
funcionalidades a sus aplicaciones:

* A nivel de modelo de datos:
- Configurar soporte para BBDD espaciales. Ejemplos de ello son: PostgreSQL 
  con PostGIS, Oracle con Spatial, etc. que permiten unir datos
  alfanuméricos habituales con nuevos campos geográficos que representen la
  localización y forma de los datos. Por ejemplo, si tenemos una tabla con las
  ciudades de un país, tendremos datos como el nombre, el número de habitantes,
  etc. y por otro lado podemos tener un punto geográfico que indique la posición
  de la ciudad en el mapa, o un polígono con la forma del término municipal.
- Incorporar campos geográficos vectoriales como un dato más en el modelo
  de datos de una aplicación, integrando y configurando las librerías
  necesarias para ello.
- Soporte para consultas a BBDD con filtros espaciales. Es decir, poder buscar
  datos no sólo por sus valores alfanuméricos, sino también por sus
  características geográficas: elementos que estén cerca de una localización,
  dentro de un área determinada, etc.
* A nivel de presentación:
- gvNIX genera automáticamente páginas para la visualización, listado,
  búsqueda, creación y edición de datos alfanuméricos y además incorpora la
  visualización sobre un mapa de estos mismos datos. Por ejemplo, si tenemos
  un listado de ciudades que se muestran sobre una tabla, se podría incorporar
  también un mapa en el que se muestre la localización de estas ciudades.
- Permite la edición de la localización de elementos. Incorpora a los
  formularios de creación y edición de datos que genera gvNIX el poder
  establecer la localización del dato que se está editando mediante la
  selección de un punto sobre un mapa.
- Generación de geoportales. Cualquier aplicación gvNIX puede incorporar
  un geoportal en el que se muestren todos los datos que se gestionan desde la
  aplicación como diferentes capas, con opciones de búsqueda, activación,
  etc., así como integración con el resto de páginas de la aplicación: 
  herramienta de edición que al seleccionar un elemento sobre el mapa, nos 
  lleva al formulario de edición de dicho elemento.
* A nivel de proyecto:
- gvNIX permite integrar y combinar distintos frameworks y librerías de tal 
  forma que desarrolladores sin conocimientos geográficos serán perfectamente capaces
  de desarrollar aplicaciones de gestión con componente geográfica.

Este es el ejemplo más claro de los beneficios de gvNIX, en la versión 1.4
conseguirá integrar no sólo Spring Framework, CXF, JasperReports, etc. con
frameworks propios de aplicaciones de geomática como Leaflet, JTS (Java
Topology Suite), Hibernate Spatial, etc.

====

[{intro}]
== *Casos de uso*

[{topic}]
== Casos de uso

[role="incremental"]
* Aplicaciones de gestión *homogéneas*
* *Integración* con procesos de negocio
* Sistemas mixtos *móvil-web*
* Gestión *datos geográficos*

[template="notesblock"]
====
*CHARLA (HOW):*

Las grandes organizaciones están en constante evolución, todos los días surgen
nuevas necesidades y requerimientos que deben cubrirse con nuevas
aplicaciones. gvNIX ofrece una infraestructura común para los desarrollos
propios y externos, garantizando que todos los proyectos son similares para
facilitar el mantenimiento y la evolución.

Ejemplos:

* Gestión del Mantenimiento Integral de Carreteras de la Diputación de Valencia.

====

[role="topic recap"]
== {gvnixsite}

image::logo_gvNIX.png[height="120"]

Gracias +
[smaller]#disid.com |# [smaller]#@disid_corp#

////

////

