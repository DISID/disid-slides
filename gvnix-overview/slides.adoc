//
// Build the presentation
//
// dzslides with embedded assets:
// asciidoc -a data-uri slides.adoc
//
// HTML5 (print):
// asciidoc -b html5 -o outline.html slides.adoc
//
 
= Visión estratégica **gvNIX**
v1.2, 17 oct 2014
:title: Visión estratégica gvNIX
:description: These slides are a strategic overview to gvNIX.
:copyright: CC BY-NC-SA 3.0
:corpsite: www.disid.com
:gvnixsite: www.gvnix.org
:imagesdir: images
:linkcss!:
:source-highlighter: highlightjs
:backend: dzslides
:dzslides-style: stormy
:dzslides-aspect: 16-9
:dzslides-transition: fade
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: monokai
:syntax: no-highlight

////

////

[template="notesblock"]
====
*CHARLA (INTRODUCCIÓN):*

Presentación: Nombre, cargo en DISID

En esta charla/presentación explicaremos qué es gvNIX, en qué se diferencia de
un framework de desarrollo.

Haremos un repaso de las funcionalidades y componentes que nos ofrece para el 
desarrollo de aplicaciones web.

Veremos las nuevas funcionalidades de la nueva versión 1.4 que saldrá en 
noviembre y una demo de una aplicación desarrollada con gvNIX.

====

[{topic}]
== ¿*Por qué* usamos *librerías*?

[role="incremental scatter"]
* Lenguaje + *Librerías API*
* Problema [detail]#programar *sólo* con lenguaje#
* Más *productividad* = *librerías* de terceros

[template="notesblock"]
====
*CHARLA (WHY):*

Habitualmente cualquier plataforma de
desarrollo: Java, C#, Python, Groovy, etc. además del lenguaje, ofrece un
conjunto de librerías que no son más que conjuntos de funciones ya 
implementadas básicas con funcionalidad imprescindible, en el caso
de la plataforma Java estas librerías se conocen como el *API Java*.

Si tratamos de programar una aplicación con cualquier lenguaje, desde cero
usando solo el lenguaje y las librerías básicas tendríamos un problema, ya que
sólo ofrecen utilidades de bajo nivel (programación concurrente, sockets,
estructuras de datos, etc) y por tanto funciones tan necesarias como manejo de
sesiones web, componentes de interfaz de usuario, envío de correo, etc.
tendríamos que desarrollarlas a mano.

En lugar de ello es más productivo y eficiente usar librerías de terceros que
ofrezcan estas funciones de más alto nivel. Librerías que además deben ofrecer
unas mínimas garantías como: soporte, a poder ser LTS; amplía documentación, 
proyecto activo y en evolución, etc.

====

[{topic}]
== *Librerías* = nuevos *problemas*

[role="incremental scatter"]
* *Diversidad* de librerías
* Librerías *independientes*
* Configuración *manual*
* *Carencia* de homogeneidad

[template="notesblock"]
====
*CHARLA (WHY):*

Esto que a priori es bueno, supone una nueva problemática para los proyectos
de desarrollo ya que en la mayoría de las ocasiones para desarrollar la
aplicación que necesitamos no nos es suficiente con usar un única librería
sino que necesitamos utilizar varias.

Esta situación genera problemas ya que cada librería es totalmente
independiente, con su propia configuración y gestión del ciclo de vida de 
los objetos que genera.

Además aunque actualmente existe disponibilidad de tal diversidad de librerías
que prácticamente se cubren todos los aspectos que se necesita en el proceso
de desarrollo, todavía es necesario una configuración e instalación manual por
parte de los desarrolladores.

Las librerías no aportan una estructura concreta a nuestros proyectos, por lo
que ésta depende de cada desarrollador y nos podemos encontrar en la situación
que cada proyecto y aplicación tiene una estructura diferente.
====

[{topic}]
== ¿*Por qué* usamos *frameworks*?

[role="incremental scatter"]
* Librerías *cohesionadas*
* *Base de desarrollo* [detail]#estándares, metodología y estructura#
* *Garantía*

[template="notesblock"]
====
*CHARLA (WHAT):*

Un framework no es mñas que un conjunto de librerías cohesionadas que ofrecen
funciones de más alto nivel y para las que se necesitan varias librerías:

Por ejemplo, un framework de persistencia de objetos: integra librerías de
log, el API JDBC, librerías para trabajar con archivos XML, etc.

Algunos framework sirven de base para el desarrollo de aplicaciones: definen un 
conjunto estándares, metodología de trabajo y estructura de proyectos que 
minora en gran medida la problemática de tener que utilizar
diversidad de librerías.

Los frameworks más serios de hoy en día, garantizan que estas funcionalidades
han sido probadas y ofrecen un soporte a largo plazo.
====

[{topic}]
== Framework = *productividad*

[role="incremental scatter"]
* *Estructura* y *configuración*
* *Integra* librerías
* *Estándares* = *colaboración*
* *Patrones* y buenas prácticas

[template="notesblock"]
====
*CHARLA (WHAT):*

Los marcos de trabajo son sinónimo de productividad porque facilitan y 
aceleran el proceso de desarrollo debido a:

* Define una estructura de aplicación, una forma homogénea de configurar y 
  usar todas las librerías que integra.
* Especifica mecanismos para integrar nuevas funciones o librerías.
* Facilita la colaboración, ya que está todo más estandarizado y definido
  según el framework. Es un código menos personal y más automatizado.
* Promueve el uso de patrones y buenas prácticas, por ejemplo arquitectura
  MVC.
  .
  Ayudan al desarrollador a enfocarse principalmente en la lógica del negocio
  o el problema al cual debe dar solución con la aplicación.
====

[{topic}]
== *Frameworks* = nuevos *problemas*

[role="incremental scatter"]
* *Múltiples* en una aplicación
* *Aspectos concretos* [detail]#DI, MVC, seguridad, ...#
* Diferente *configuración*
* *Homogeneidad* <- problema

[template="notesblock"]
====
*CHARLA (WHY):*

Sin embargo, aún con toda la productividad que proporcionan los frameworks,
sigue siendo un problema para los desarrolladores porque las aplicaciones 
necesitan de varios frameworks y/o librerías para poder satisfacer los
requerimientos del usuario.

Ocurre algo parecido a lo que ocurría con las librerías, las librerías agrupan
funciones de utilidad, los frameworks agrupan librerías que dan solución a un
aspecto concreto de una aplicación.

Por ejemplo:

* Spring Framework, soluciona cómo se suministran los objetos a otros objetos
  en lugar de dejar que sean éstos quienes creen el propio objeto.
* Spring MVC, gestión de la vista y control de aplicaciones web.
* Spring Security, autenticación y autorización.
* CXF, desarrollo de servicios web
* JasperReports, desarrollo de informes
* Bootstrap, jQuery, etc.

Ahora el problema no está en integrar librerías, sino en integrar frameworks,
en configurarlos, en resolver colisiones de dependencias, etc etc etc

Aunque es cierto que los frameworks permiten que distintas aplicaciones tengan
la misma estructura y por tanto introduce cierta homogeneidad en los proyectos
de una organización, existe un problema: cada framework define su propia
estructura, por lo que si por cualquier circunstancia utilizamos frameworks
diferentes en distintas aplicaciones se pierde la homogeneidad en esos
proyectos.
====

[{topic}]
== *Herramienta desarrollo* = *productividad++*

[role="incremental scatter"]
* Procesos automáticos [detail]#integrar frameworks, configurar, ...#
* Patrones y *buenas prácticas++*
* Focalizar en lógica de negocio
* *Homogeneidad++*

[template="notesblock"]
====
*CHARLA (WHAT):*

Una herramienta de desarrollo es una aplicación para crear otras
aplicaciones basadas en varios frameworks y además integrar,
configurar esos frameworks y cómo se relacionan.

Las herramientas de desarrollo proporcionan patrones y buenas prácticas más
allá de cada framework o librería:

* El ciclo de vida va desde el análisis hasta el mantenimiento
* Mayor porcentaje del tiempo dedicado a lógica de negocio

La homogeneidad no depende del framework, depende de la herramienta que se
utiliza, definiendo una estructura de proyectos que debe ser única para 
cualquier tipo de proyecto.

====

== Qué es gvNIX

[{statement}]
*gvNIX* es una *herramienta* de *desarrollo* rápido de aplicaciones web

[template="notesblock"]
====
*CHARLA (HOW):*

Pues bien, *gvNIX es una herramienta de desarrollo rápido de aplicaciones
web*. Es la herramienta de desarrollo que nos va a proporcionar todos los
beneficios de un herramienta de desarrollo para crear aplicaciones web.

====

[{topic}]
== *Beneficios* gvNIX

[role="incremental scatter"]
* No limita [detail]#manteniento evolutivo ni correctivo#
* Usuario gvNIX [detail]#*desarrollador* de aplicaciones#
* Uso por capas [detail]#modelo, modelo-control, modelo-control-vista#
* Independencia aplicaciones -> gvNIX

[template="notesblock"]
====
*CHARLA (HOW):*

Beneficios:

* La evolucion de las aplicaciones no están bloqueda por la evolución de
  gvNIX. Ejemplos:
** Integrar una nueva funcionalidad en una aplicación no requiere que 
   previamente se añada a gvNIX.
** Los estándares Java garantizan que las aplicaciones funcionarán en
   cualquier servidor de aplicaciones, sin embargo, estos estándares también
   evolucionan y aplicaciones que funcionaban perfectamente en versiones de
   servidores antiguas, por ejemplo JBoss 5, pueden no funcionar en versiones 
   más recientes, por ejemplo JBoss 6. Hacer los cambios necesarios para que
   una aplicación funcione sobre nuevos servidores de aplicaciones no requiere
   que previamente se añada a gvNIX.
** Correcciones de errores.
* En todos estos casos, son funcionalidades de la aplicación que no dependen 
  de gvNIX, se pueden desarrollar, mejorar, modificar y/o corregir en la propia 
  aplicación y posteriormente se reporta al proyecto gvNIX para incluir la 
  mejora en futuras versiones.
** Un posible proceso de atención de incidencias o solicitud de mejoras que 
   se puede seguir con gvNIX es: 
   1. el usuario final informa de una incidencia, mejora, etc. en una 
      aplicación al equipo de desarrollo de esa aplicación.
   2. el equipo de desarrollo da solución a la incidencia, pudiendo así dar
      mejores tiempos de respuesta que si se gestionara desde gvNIX.
   3. el equipo de desarrollo reporta la incidencia en el ámbito de gvNIX al
      proyecto gvNIX, incluyendola en la hoja de ruta y corrigiendola dentro
      de la siguiente versión de gvNIX.
* Libertad para usar gvNIX en cualquiera de las capas de la arquitectura de la
  aplicación. Se pueden utilizar gvNIX para generar cualquiera de las capas de
  la aplicación: sólo modelo, modelo-controlador o modelo-vista-controlador.
  De esta forma gvNIX ayuda en aquello que necesita el proyecto y permite
  integrar otras tecnologías en una aplicación desarrollada con gvNIX. Por
  ejemplo, se puede desarrollar una aplicación con gvNIX cuya vista esté
  desarrollada con ExtJS.
* Diferencia explícita entre desarrolladores de aplicaciones como el usuario
  tipo de gvNIX, y usuarios finales de la aplicaciones desarrolladas.
* Importante es que al *no contener ningún componente en tiempo de ejecución* 
  no interfiere en el despliegue de las soluciones ni crea dependencias con el
  producto final, de forma tal que resulta transparente para el despliegue en
  producción.

====

[{topic}]
== Características

[role="incremental scatter"]
* *Multiplataforma* y fácil de instalar
* Generación *no-intrusiva* de código
* [detail]#Buenas prácticas desde# *Análisis*
* Proyectos *JEE* estándar
* *No* añade *dependencias* de componentes

[template="notesblock"]
====
*CHARLA (HOW):*

* *Es multiplataforma y fácil de instalar*.
  gvNIX es fácil de instalar tanto como herramienta independiente que funciona
  en Windows, Mac OSX, Linux o como herramienta integrada en un entorno de
  desarrollo: STS o Eclipse.
  Los únicos requerimientos son Java 6 SDK y Apache Maven 3. Una vez
  instalados, se descarga la distribución de gvNIX, se descomprime y se añade
  al PATH del sistema y lanzamos el entorno con el comando gvnix.
* *Sistema de generación automática de código*.
  Crea código en unidades de compilación separadas del código fuente creado
  por los desarrolladores, de esta forma, la generación de código es 
  totalmente inocua porque independiza el ciclo de vida del código generado del
  ciclo de vida del código mantenido por los desarrolladores.
* *Potencia el uso de buenas prácticas*.
  Todo proyecto de gvNIX comienza por un análisis del dominio del problema
  plasmado sobre un modelo de clases que sirve como punto de partida del
  proyecto.  Un sistema de ayuda integrado guía al desarrollador a lo largo
  del ciclo de vida de un proyecto*.
  .
  Hay que ver que el ciclo de vida va más allá de Maven: no es solo compilar,
  ejecutar tests, desplegar, etc. es forzar para que se hagan los análisis,
  facilitar incluir pruebas unitarias, funcionales, etc.
* *Proyectos JEE estándar* Los proyectos creados con gvNIX son aplicaciones Java
  que cumplen con el estándar JEE
* *No sobrecarga el entorno de ejecución*.
  gvNIX no añade ningún tipo de librería requerida en tiempo de ejecución.

TODO: Pensar diferencia con un sistema de trabajo basado en Maven, donde nos 
presentaban que ellos tenían una forma de trabajar muy ordenada que les 
permitía focalizar en la lógica de negocio.

====

== Arquitectura gvNIX

[{middle}]
image::gvnix-arquitectura-develtime.png[caption="Arquitectura de gvNIX",width="570"]

[template="notesblock"]
====
*CHARLA (HOW):*

El framework ha sido implementado con lenguaje Java y sigue un modelo de
arquitectura orientado a componentes sobre plataforma OSGi en el que cada
funcionalidad que ofrece el framework es implementada como un 
add-on que colabora con el resto en las distintas tareas de generación.
Esta arquitectura es empleada en el desarrollo de grandes sistemas modulares
como, por ejemplo Eclipse, JBoss, Servicemix y un largo etcétera. 

*¿Qué es OSGi?*

* OSGI (Open Services Gateway Initiative) es una capa sobre Java que permite
crear módulos o componentes que pueden interactuar entre sí en tiempo de 
ejecución.
* OSGi intenta solventar los problemas del tradicional "classloader" de la 
máquina virtual y de los servidores de aplicaciones Java (como JINI).
* En OSGI, cada componente tiene su propio classpath separado del resto de 
classpath de los demás módulos.

OSGi ofrece:

* OSGI proporciona un entorno que soporta el despliegue dinámico de
  componentes ("bundles" o módulos).
* Sistema modular que incluye reglas de visibilidad, gestión de dependencias y versionado de los bundles.
* La instalación, arranque, parada, actualización y desinstalación de bundles se realiza dinámicamente en tiempo de ejecución sin tener que detener por completo la plataforma.
* Es una arquitectura orientada a servicios.
* Los servicios pueden ser registrados y consumidos dentro de la VM.

Esta imagen ilustra la separación entre gvNIX y los proyectos y se aprecia como efectivamente es una herramienta que genera nuestras aplicaciones.

====

== Intérprete de comandos

ifndef::backend-dzslides[]
image::gvnix-shell-eclipse.png[caption="Intérprete de comandos",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-shell-eclipse.png[caption="Intérprete de comandos"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Desde el punto de vista de su uso, gvNIX está diseñado como 
un intérprete de comandos interactivo al estilo de Rails o de Grails. Para 
facilitar su uso tiene autocompletado de los comandos y ayuda contextual. 
Además en todo momento nos mostrará solo los comandos que sean válidos y nos 
dará pistas de cuál es la siguiente tarea a realizar si estamos un poco 
perdidos.

En la imagen se ve cómo se interactúa con Roo.

Cada componente proporciona al shell un conjunto de comandos a través de los
cuales proporciona sus funciones al desarrollador, el cual decide si aplica o
no durante el proceso de desarrollo.

Además el propio framework proporciona sus propios comandos o funcionalidades
para facilitar el desarrollo. Los más destacados son:

* *help*: Muestra al desarrollador todos los comandos o funcionalidades 
  disponibles.
* *hint*: Aconseja el siguiente paso posible en el proceso de desarrollo.

====

[{topic}]
== Madurez de gvNIX

[role="incremental scatter"]
* *Funcionalidades* que incluye
* *Tecnología* de las aplicaciones
* *Casos* de *uso*
* *Sostenibilidad* del proyecto

[template="notesblock"]
====
*CHARLA (HOW):*

Muy bien, está claro por qué gvNIX es más que un framework, que no 
bloquea el ciclo de vida de las aplicaciones, es decir no tiene sentido 
aquello de "si gvNIX no lo soporta -> no se puede hacer con gvNIX", que se 
ha utilizado una tecnología que va a permitir que gvNIX crezca en la medida 
que se necesite en la DGTI. Pero, *¿está gvNIX lo suficientemente maduro?*

Para contestar a esta pregunta vamos a ver:

* *Funcionalidades* desarrolladas hasta la fecha y *nuevas funcionalidades* de la versión 1.4
* Tecnologías que gvNIX incluye y sobre las que base las aplicaciones.
* *Sostenibilidad* del proyecto

- Dicho esto, proyectos relacionados con las funcionalidades y
automatismos que nos proporciona NIX: Pues comentáis los que hay tanto
dgti como fuera dgti.

- Y volviendo a recordar, pero esto no es hablar de la madurez de NIX,
pues la base de NIX es un proyecto como spring etc.

====

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* *Scaffolding*
* Seguridad *autorización* y *autenticación*
* Integración con *SAFE*
* Exportar/Importar *servicios web*
* Calidad de desarrollo [detail]#pruebas unitarias y funcionales#

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* *Informes*
* *Ingeniería inversa*
* Control de *concurrencia*
* *Auditoría* e *histórico* de cambios en bbdd

[{topic}]
== Funcionalidades de gvNIX

[role="incremental scatter"]
* Interfaz usuario *adaptativa* [detail]#(responsive UI)#
* Componentes avanzados: *tablas AJAX*, *lupa*
* Maestro -> detalle *multinivel*

[{topic}]
== Nuevas funcionalidades de gvNIX

[role="incremental scatter"]
* Monitorización *rendimiento* en producción
* *Asistente* para *filtros*
* Componente *geográfica*

[template="notesblock"]
====
*CHARLA (HOW):*

TODO Objetivo: Visualizar que existe una inversión y un plan desde la dgti sobre el NIX.

*Ingeniería inversa de base de datos*

Permite crear el modelo completo de entidades Java de la aplicación vía la introspección de la base de datos del proyecto. Además, incrementalmente mantiene el modelo de entidades sincronizado con todos los cambios realizados en el modelo de datos.

*Scaffolding*

Construcción automática de la aplicación a partir de un meta-modelo definido 
en anotaciones Java, en sólo unos minutos se puede generar una aplicación
funcional.

*Generación automática* de clientes de sistemas externos: email, JMS y WebServices.

*Exponer automáticamente* servicios de la aplicación vía interfaz WebService
gvNIX permite integrar la aplicación con procesos de negocio remotos
fácilmente. A partir de código Java con anotaciones JAX-WS o partir de
archivos WSDL, genera automáticamente toda la infraestructura necesaria para
recibir llamadas desde procesos externos.

*Control de concurrencia optimista*

En entornos multiusuario, como las aplicaciones web, es frecuente que dos usuarios accedan simultáneamente al mismo registro para editarlo. El control de concurrencia permite evitar que se pierdan los cambios del primero que guarde.

El patrón de control de concurrencia más aceptado en entornos web es el conocido
como control de concurrencia optimista. La forma más habitual de implementarlo es utilizar un campo de versión que debe incluirse en todas las tablas del modelo de datos.

En organizaciones públicas el modelo de datos sigue unas políticas de seguridad muy rigurosas y es frecuente que no se pueda añadir un nuevo campo de versión.

gvNIX proporciona una implementación del control de concurrencia optimista basado en el estado de los objetos, igualmente efectivo pero no intrusivo.

*Seguridad*

Incorpora control de acceso y autorización por roles de usuario fácilmente.

*Informes*

Utiliza JasperReports para generar informes operativos dinámicamente y en diferentes formatos: PDF, LibreOffice, MSOffice, CSV. Cada informe es accesible desde el menú de la aplicación y genera un formulario previo para especificar los parámetros de filtrado.

Los informes son totalmente funcionales desde su creación, incluyendo la generación de la plantilla .jrxml para permitir una personalización cómoda y fácil.

*Pruebas unitarias y funcionales*

Genera automáticamente pruebas de calidad de código, tanto unitarias con Junit como funcionales con Selenium.

*Generación de pantallas con diseño adaptativo* 

Gestionar la información desde cualquier dispositivo: tableta, PC, móvil, etc.

*Soporte de HTML5 y CSS3*

Ampliar las opciones de configuración de la visualización de los datos
tabulares por el usuario final: agrupación de datos, guardar configuración,
etc.

*Componente lupa*

TODO

*Auditoría de cambios en base de datos*

TODO

*Histórico de cambios de base de datos*

TODO

Como no, 2 de las nuevas funcionalidades de la versión 1.4 que saldrá a
finales de noviembre:

*Monitorización rendimiento en producción*

TODO

====

== Componente geográfica

[{middle}]
image::map_generic.png[caption="Componente geográfica",width="570"]

[template="notesblock"]
====
*CHARLA (HOW):*

Cada vez son más áreas del saber que requieren el uso de datos geoespaciales
para cumplir con mayor acierto sus procesos, como la gestión pública, gestión
medioambiental, ingeniería, entre otras, por lo que existe hoy en día una
creciente necesidad de aplicaciones web que requieren compartir e integrar
datos georeferenciados con datos alfanuméricos para realizar diferentes tipos
de análisis espacio-territoriales y ayudar en la toma de decisiones.

De igual forma, los ciudadanos comunes se interesan cada vez más en 
herramientas que les permitan visualizar mapas y obtener información de su 
interés (rutas de transporte, estado del tráfico, sitios turísticos, 
localización de direcciones).

Una de las principales necesidades a cubrir en una aplicación que gestione
datos con componente geográfica es la gestión de datos en una BBDD con soporte
espacial. Ejemplos de ello son: PostgreSQL con PostGIS, Oracle con Spatial,
etc.  En estos casos se trata de incluir, junto con el resto de datos
alfanuméricos habituales, nuevos campos geométricos que representen la
localización y forma de los datos. Por ejemplo, si tenemos una tabla con las
ciudades de un país, tendremos datos como el nombre, el número de habitantes,
etc. y por otro lado podemos tener un punto geográfico que indique la posición
de la ciudad en el mapa, o un polígono con la forma del término municipal.

La problemática principal que tienen los tipos de datos geográficos es que las
librerías que suelen usar los desarrolladores para trabajar con las BBDD no
los soportan por defecto. Es necesario integrar y configurar librerías
adicionales que incluyan dicho soporte.

A nivel de modelo de datos gvNIX permite:

* Incorporar atributos geográficos vectoriales como un dato más en el modelo
  de datos de una aplicación, integrando y configurando las librerías
  necesarias para ello.
* Soporte para consultas a BBDD con filtros espaciales. Es decir, poder buscar
  datos no sólo por sus valores alfanuméricos, sino también por sus
  características geográficas: elementos que estén cerca de una localización,
  dentro de un área determinada, etc.

A nivel de presentación el objetivo principal es la visualización de los datos 
sobre un mapa, empleando para ello librerías Javascript como Leaflet. En este 
aspecto, las funcionalidades son:

* gvNIX genera automáticamente páginas para la visualización, listado,
  búsqueda, creación y edición de datos alfanuméricos y además incorpora la
  visualización sobre un mapa de estos mismos datos. Por ejemplo, si tenemos
  un listado de ciudades que se muestran sobre una tabla, se podría incorporar
  también un mapa en el que se muestre la localización de estas ciudades.
* Permite la edición de la localización de elementos. Incorpora a los
  formularios de creación y edición de datos que genera gvNIX el poder
  establecer la localización del dato que se está editando mediante la
  selección de un punto sobre un mapa.
* Generación de geoportales. Cualquier aplicación gvNIX puede incorporar
  un geoportal en el que se muestren todos los datos que se gestionan desde la
  aplicación como diferentes capas, con opciones de búsqueda, activación,
  etc., así como integración con el resto de páginas de la aplicación: 
  herramienta de edición que al seleccionar un elemento sobre el mapa, nos 
  lleva al formulario de edición de dicho elemento.

A nivel de proyecto:

* gvNIX permite integrar y combinar distintos frameworks y librerías de tal 
  forma que desarrolladores sin conocimientos geo serán perfectamente capaces
  de desarrollar aplicaciones de gestión con componente geográfica.

Este es el ejemplo más claro de los beneficios de gvNIX, en la versión 1.4
conseguirá integrar no sólo Spring Framework, CXF, JasperReports, etc. con
frameworks propios de aplicaciones de geomática como Leaflet, JTS (Java
Topology Suite), Hibernate Spatial, etc.

====

== Tecnología

ifndef::backend-dzslides[]
image::gvnix-arquitectura-runtime.png[caption="Arquitectura 3 capas",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-arquitectura-runtime.png[caption="Arquitectura 3 capas"]
endif::[]

[{notes-caption}]
====
*CHARLA (HOW):*

Habitualmente las aplicaciones web JavaEE se estructuran en tres capas: la
capa web, la de control y la de modelo del dominio.

La capa de dominio del problema suele contener una "sub-capa" de servicios  
que ofrecen eso, servicios, al resto de capa e incluso a clientes remotos. 
Tiene otra "sub-capa" de acceso a datos donde habitualmente tenemos 
los DAOs, que se encargan de la persistencia de datos. Finalmente incluye las
clases que modelan las entidades del dominio, que se encargan no solo de 
modelar el dominio sino también de la validación de sus datos e incluso su 
serialización a JSON.

TODO: Lo que ofrece Spring Framework en ejecución.
====

== Tecnología

ifndef::backend-dzslides[]
image::Java-web-fw-report.png[caption="Tecnología consolidada",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::Java-web-fw-report.png[caption="Tecnología consolidada"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

¿Y que hay de la tecnología que incluye gvNIX en las aplicaciones? Pues es la
tecnología más utilizada en la actualidad. Spring MVC es el framework web
comunmente utilizado. El 40% de la población de estudio manifestó que
utilizaba Spring MVC.

Dos datos muy rápidos sobre las tecnologías que integra gvNIX en las
aplicaciones:

* Spring MVC es el framework para desarrollo web más utilizado

====

== Tecnología

ifndef::backend-dzslides[]
image::Java-tools-and-technologies-2014.jpg[caption="Enterprise Java 2014",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::Java-tools-and-technologies-2014.jpg[caption="Enterprise Java 2014"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

*Por qué esta pila tecnológica?*

Las aplicaciones generadas por gvNIX estan sobre una base
tecnológica asentada, robusta, moderna y sobre todo ampliamente utilizada a
nivel mundial lo que garantiza el futuro de las aplicaciones desarrolladas con
gvNIX.

Por tanto, está maduro gvNIX, *claro*, lo contrario sería decir que Spring, 
que jQuery, que Hibernate no están maduros, pues como hemos visto gvNIX no es 
un FW sino una herramienta de desarrollo que surge para solventar el problema
de la proliferación de tantos FW independientes.

====

== Aplicación con ExtJS

ifndef::backend-dzslides[]
image::gvnix-arquitectura-runtime-ExtJS.png[caption="Aplicación con ExtJS",width="570"]
endif::[]

ifdef::backend-dzslides[]
image::gvnix-arquitectura-runtime-ExtJS.png[caption="Aplicación con ExtJS"]
endif::[]

[template="notesblock"]
====
*CHARLA (HOW):*

Vamos a ver un ejemplo, ¿qué pasa si queremos usa una tecnología diferentes 
con gvNIX? Nada, podemos utilizar gvNIX para aquellas capas en las que nos
pueda ayudar y facilitar el desarrollo y aquellas capas que queremos una
tecnología diferente hacerlo a mano.

Una de las grandes ventajas de Spring Framework es que permite cambiar
fácilmente cualquiera de los elementos de una aplicación, no sólo los
soportados, sino que proporciona los mecanismos necesarios para integrar
cualquier librería o estándar nuevo en cualquiera de las versiones del
framework. A diferencia por ejemplo de entornos como Developer.

Por ejemplo, el echo que gvNIX no genere aplicaciones con ExtJS no implica que
no se pueda usar gvNIX, simplemente el desarrollador tendrá que incluir a
mano ExtJS en la aplicación generada con gvNIX.

Aún así el desarrollador obtendrá toda la productividad que le brinda gvNIX,
aunque evidentemente sólo en 2 capas de la aplicación.
====

[{topic}]
== Casos de uso

[role="incremental"]
* Aplicaciones de gestión *homogéneas*
* Migración a *entorno web*
* *Integración* con procesos de negocio
* Sistemas mixtos *móvil-web*
* Gestión *datos geográficos*
* *Portlets* Liferay

[template="notesblock"]
====
*CHARLA (HOW):*

*Aplicaciones de gestión*

Las grandes organizaciones están en constante evolución, todos los días surgen
nuevas necesidades y requerimientos que deben cubrirse con nuevas
aplicaciones. gvNIX ofrece una infraestructura común para los desarrollos
propios y externos, garantizando que todos los proyectos son similares para
facilitar el mantenimiento y la evolución.

* Aplicaciones de gestión medias-grandes con un alto número de accesos
concurrentes vía web.
* Aplicaciones de gestión con gran volumen de datos.

*Migración de aplicaciones a entorno web*

La evolución tecnológica durante años hace que en las organizaciones exista
gran diversidad de aplicaciones que por diferentes motivos carecen de
mantenimiento.

gvNIX es un entorno a la medida de cualquier perfil que permite migrar
aplicaciones de gestión de datos rápidamente.

*Integración de aplicaciones en procesos de negocio*

Las organizaciones acumulan diversidad de procesos en un entorno tecnológico
heterogéneo: cliente/servidor, aplicaciones web, servicios SOA, etc.

gvNIX permite conectar entre sí distintas aplicaciones con distintas
tecnologías con tiempos y costes de desarrollo reducidos.

*Sistemas mixtos móvil-web*

Poner arquitectura medioambiente

*Aplicaciones de gestión de datos con componente geo*

Proof geo

*Aplicaciones de para el ciudadano incrustadas en portales Liferay*

Ejemplo portlet buscador Sanidad; o de gestión.

====

[{topic}]
== Sostenibilidad

[role="incremental"]
* Escalabilidad [detail]#basada en múltiples contribuidores#
* Comunidad de desarrollo [detail]#empresas, organizaciones, universidades#
* Cooperación = mayor calidad
* Sostenibilidad <- facilitar y gestionar la cooperación

[template="notesblock"]
====
*CHARLA (HOW):*

Es innegable el papel que está jugando el software libre en el ámbito de la
gestión de empresas y administraciones públicas. Hasta hace unos pocos años,
se consideraba una rareza y aventurarse en un proyecto Open Source en la
empresa o en una administración pública, era cuanto menos, bastante
arriesgado. Hoy día, estos proyectos, en algunos ámbitos, están desplazando a
sus homólogos de software privativo. Una de las fortalezas mayores desde
nuestro punto de vista es la posibilidad de *escalar el producto en base a las
aportaciones de múltiples contribuidores*, y que en el software privativo queda
reducido a los recursos de los que dispone la propia empresa. Es decir, que
uno de los factores más importantes corresponde a las comunidades de
desarrollo de software.

Los objetivos de una *comunidad de desarrollo* de software es aglutinar grupos
de personas, empresas, organizaciones, universidades e individuos con un
objetivo y beneficio común sobre la base de promover el acceso y distribución
de una herramienta software permitiendo la libertad de su uso, estudio, copia,
modificación y redistribución a todo aquel que lo desee. Empresas 
que entorno al desarrollo de un modelo de negocio basado en el conocimiento
compartido, ve que el hecho de que las herramientas que utilizan para la
producción de las soluciones que ofrece, sean cada vez más potentes, le ofrece
más oportunidades. De ahí que a esas empresas y organizaciones les puede
interesar que se potencie gvNIX, etc.

La *cooperación* entre estos grupos de personas y organizaciones en todos los
ámbitos de la producción del software (usuarios, desarrolladores,
documentadores, testers, traductores, ...) permite generar las sinergias
necesarias para conseguir una *mejora sustancial de la calidad del software*,
así como de una mayor difusión y sostenibilidad en el tiempo, y primando el
beneficio de la sociedad sobre cualquier otro.

Esa *sostenibilidad* pasa por potenciar, facilitar y dirigir todas esas 
colaboraciones y aportaciones de empresas y organizaciones que, por afinidad 
con los intereses en el modelo de negocio, quieran partiendo de gvNIX 
enriquecerlo.

====

[{topic}]
== Crear las condiciones para un proyecto sostenible

[role="incremental scatter"]
* Distribuciones [detail]#pública y privada#
* Fomentar la cooperación
* Internacionalización
* Entidad gestora

[template="notesblock"]
====
*CHARLA (HOW):*

Para facilitar y dirigir todas las colaboraciones y aportaciones de empresas y 
organizaciones que hacen falta 4 elementos fundamentales:

*Diferenciar distribuciones públicas*, como gvNIX, de las privadas, como gvNIX
DGTI, con el objetivo de facilitar la contribución al código fuente de gvNIX.

Desde esta visión, generar y potenciar una distribución pública repercutirá en
el beneficio de toda la comunidad, tanto aquellos que utilicen la distribución
pública como aquellos que utilicen una distribución privada, ya que todos los
complementos de interés general contribuidos a la distribución pública estarán
automáticamente y por defecto incluidos en cualquier distribución privada.

*Fomentar la cooperación*, es decir, más allá de los conceptos teóricos,
filosóficos y jurídicos, un proyecto software se desarrolla gracias a una 
serie de herramientas técnicas: gestores de proyectos, control de versiones de 
código, wikis, listas de correo, gestores de errores o bugs, etc.; que 
facilitan la colaboración simultánea, deslocalizada y la coordinación de 
los miembros.

*Internacionalización* o conjunto de tareas a realizar para que el
proyecto pueda expandirse a distintas regiones, como forma de crecimiento de
la comunidad de desarrollo y así conseguir involucrar a más organizaciones
y empresas para ganar en calidad, desarrollo del producto, etc.

Una *entidad gestora del proyecto*, que vele por los intereses del proyecto, que
defina y modere el modelo de sostenibilidad, que organice la comunidad de
desarrollo, la difusión, los recursos del proyecto, etc. 

====

[role="topic recap"]
== Demo: Entidades

image::petclinic-uml.png[caption="Análisis del dominio",width="570"]

[role="topic recap"]
== Demo: Funcional

image::../wireframes/wireframes.png[caption="Análisis funcional",width="570"]

[template="notesblock"]
====
*CHARLA (HOW):*

El objetivo de esta demo es ver un ejemplo de aplicación que incluye 
funcionalidades que se podrán desarrollar con la nueva versión de
gvNIX, la 1.4 que saldrá en noviembre de este año:

* Interfaz adaptativo (desde 1.3)
* Patrones de pantallas (desde 1.3)
* Asistente para filtros (1.4)
* Monitorización rendimiento en producción (1.4)
* Componente geográfica (1.4)

Aunque con gvNIX se pueden desarrollar aplicaciones siguiendo distintos
métodos, el que mejor se ajusta a las características de gvNIX es DDD o
*Desarrollo Dirigido por el Dominio*:

* Un proyecto de gvNIX debería comenzar por un análisis del dominio 
  y un análisis funcional, de tal forma que sobre las pantallas funcionales
  pueda concretarse con el usuario final el flujo y organización funcional de
  las mismas y seamos capaces de revisar el análisis del dominio para que se
  ajuste a los requerimientos validados con el usuario sobre las pantallas 
  funcionales.
* Si la aplicación tiene interfaz de usuario, se genera automáticamente y 
  se ajusta la interfaz a las especificaciones de requerimientos.
* A continuación se inicia un proceso evolutivo donde se codifica la lógica 
  de negocio y las pruebas unitarias para hacer crecer el sistema hasta tener 
  la aplicación final.

La aplicación demo es para *gestión de una clínica veterinaria*. Los usuarios 
de la aplicación son trabajadores de una clínica que, en el desempeño de su
trabajo, necesitan ver y gestionar información de veterinarios, agenda de
visitas, clientes y sus mascotas.

Veremos cómo se ajusta el interfaz automáticamente al dispositivo, los
patrones de pantallas y cómo se unen los datos alfanuméricos con los
geográficos.

Este diagrama de clases representa un modelo simplificado del dominio del
problema de una clínica veterinaria.

====

[role="topic recap"]
== {gvnixsite}

[{middle}]
image::logo_gvNIX.png[height="120"]

////

== \\

image::logo_gvNIX.png[role="pull-right",height="50"]

[{statement}]
Distribuciones

[template="notesblock"]
====

TODO: Esta no

TBC: Actualmente hay una distribución que incluye todo.
TBC: Proceso de release actual.

TBC: Nueva organización. Explicar.
* Spring Roo.
* gvNIX.
* gvNIX DGTI.
TBC: Nuevo proceso de release. gvNIX independiente de Roo (al menos versiones
minor) y gvNIX DGTI independiente de gvNIX.
====

== \\

image::logo_gvNIX.png[role="pull-right",height="50"]

Proyecto de código abierto *GPL v3*

[{stepwise}]
* www.gvnix.org & documentacion
* github.com/DISID/gvnix & samples
* sourceforge.net/projects/gvnix
* code.google.com/p/gvnix/source & issues
* stackoverflow.com

[template="notesblock"]
====
*CHARLA (WHAT):*

gvNIX es un proyecto de código abierto bajo licencia GPL v3.

Las 4 libertades que obtiene la organización al utilizar software de código
abierto:

1. Libertad para ejecutar el programa en cualquier sitio, con cualquier propósito y para siempre. 
2. Libertad para estudiarlo y adaptarlo a nuestras necesidades. Esto exige el acceso al código fuente. 
3. Libertad de redistribución, de modo que se nos permita colaborar con vecinos y amigos. 
4. Libertad para mejorar el programa y publicar las mejoras. También exige el código fuente.

[width="100%",cols="<50%,<50%",]
|=======================================================================
|Página principal del proyecto |http://www.gvnix.org
|Código fuente |https://github.com/DISID/gvnix/
|Binarios |http://sourceforge.net/projects/gvnix/files/
|Repositorio Maven |https://code.google.com/p/gvnix/source/browse/
|Soporte |https://code.google.com/p/gvnix/issues/list

http://stackoverflow.com/questions/tagged/gvnix
|Documentación |http://www.gvnix.org/documentacion

https://github.com/DISID/gvnix-samples
|=======================================================================

====

////

